#!/usr/bin/env python

# References:
# pynetbox API:
#  https://pynetbox.readthedocs.io/en/latest/index.html


ANSIBLE_METADATA = {
    'metadata_version': '1.0',
    'status': ['preview'],
    'supported_by': 'Pedro Antunes <pedro.antunes@forcepoint.com>'
}

DOCUMENTATION = '''
---
module: forcepoint_netbox_interfaces

short_description: This is my sample module

version_added: "2.7"

description:
    - "This modules is able to manipulate the interface information related to a network device present on Netbox."

options:

author:
    - Pedro Antunes <pedro.antunes@forcepoint.com>
'''

EXAMPLES = '''
# Just connect the interfaces
- name: Connect the interfaces
  forcepoint_netbox_connect:
    connect_interfaces: true
    create_interfaces: false
'''

RETURN = '''
lldp_neighors:
    description: lldp_neighors
    type: str
netbox_neighors:
    description: lldp_neighors
    type: str
'''


import sys
import pynetbox
import re
import socket
from ansible.module_utils.basic import AnsibleModule


napalm_found = False
try:
    from napalm import get_network_driver
    from napalm.base import ModuleImportError
    napalm_found = True
except ImportError:
    pass


IGNORE_IFD_PATTERN = '(^(dsc|gre|demux0|cbp0|ipip|lsi|vlan|irb|pimd|pime|mtun|\.local\.|pime|pimd|tap|pip0|pp0)$)' \
                 '|(^(lsi.*)$)' \
                 '|(^(lo0\.16384|lo0\.16385)$)' \
                 '|(^(sp|lc|pfe|pfh|mt|ip|gr|pd|pe|ut|vt)\-)' \
                 '|(^(bme0|rbeb|bme1|jsrv|esi|vtep|em1|em2))' \
                 '|(^(lt)-\d+\/\d+\/\d+$)' \
                 '|(^.*\.(16386|32767|32768)$)'

IGNORE_MAC_PATTERN = '^02\:00\:0'


MANAGEMENT_IFD_PATTERN = 'Management|fxp0|em0|em1|me0|vme'


def _is_management_interface(if_name):
    return re.match(MANAGEMENT_IFD_PATTERN, if_name)

def _ignore_interface(if_name):
    return re.match(IGNORE_IFD_PATTERN, if_name)

def _ignore_mac_address(mac):
    return re.match(IGNORE_MAC_PATTERN, mac)


def _get_interface_names(interfaces):
    names = []
    for i in interfaces:
        names.append(i.name)
    return names

def _get_interface_by_name(interfaces, name):
    for i in interfaces:
        if i.name == name:
            return i

def _found_ip_address(addresses, address):
    if not addresses:
        return False

    for a in addresses:
        if str(a.address) == address:
            return True

    return False

def _get_ip_address(addresses, address):
    if not addresses:
        return

    for a in addresses:
        if str(a).split('/')[0] == address:
            return a

    return


def run_module():
    # define available arguments/parameters a user can pass to the module
    module_args = dict(
        netbox_url=dict(type='str', required=True),
        netbox_token=dict(type='str', required=True),
        hostname=dict(type='str', required=False, aliases=['host']),
        username=dict(type='str', required=False),
        password=dict(type='str', required=False, no_log=True),
        provider=dict(type='dict', required=False),
        dev_os=dict(type='str', required=False),
        timeout=dict(type='int', required=False, default=60),
        ignore_notimplemented=dict(type='bool', required=False, default=False),
        args=dict(type='dict', required=False, default=None),
        optional_args=dict(type='dict', required=False, default=None)
    )


    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )


    provider = module.params['provider'] or {}

    # allow host or hostname
    provider['hostname'] = provider.get('hostname', None) or provider.get('host', None)
    # allow local params to override provider
    for param, pvalue in provider.items():
        if module.params.get(param) is not False:
            module.params[param] = module.params.get(param) or pvalue

    hostname = module.params['hostname']
    username = module.params['username']
    netbox_url = module.params['netbox_url']
    netbox_token = module.params['netbox_token']
    dev_os = module.params['dev_os']
    password = module.params['password']
    timeout = module.params['timeout']
    args = module.params['args'] or {}
    ignore_notimplemented = module.params['ignore_notimplemented']
    implementation_errors = []


    argument_check = {'hostname': hostname, 'username': username, 'dev_os': dev_os}
    for key, val in argument_check.items():
        if val is None:
            module.fail_json(msg=str(key) + " is required")

    if module.params['optional_args'] is None:
        optional_args = {}
    else:
        optional_args = module.params['optional_args']

    try:
        network_driver = get_network_driver(dev_os)
    except ModuleImportError as e:
        module.fail_json(msg="Failed to import napalm driver: " + str(e))


    try:
        device = network_driver(hostname=hostname,
                                username=username,
                                password=password,
                                timeout=timeout,
                                optional_args=optional_args)
        device.open()
    except Exception as e:
        module.fail_json(msg="cannot connect to device: " + str(e))

    data = {}

    result = dict(
        changed=False
    )


    try:
        for getter in ['interfaces_ip' ]:
            getter_function = "get_{}".format(getter)
            get_func = getattr(device, getter_function)
            data[getter] = get_func(**args.get(getter, {}))

        result['interfaces_ip'] = data['interfaces_ip']

    except NotImplementedError:
        if ignore_notimplemented:
            implementation_errors.append(getter)
        else:
            module.fail_json(
                msg="The filter {} is not supported in napalm-{} [get_{}()]".format(
                    getter, dev_os, getter))
    except Exception as e:
        module.fail_json(msg="[{}] cannot retrieve device data: ".format(getter) + str(e))

    interfaces_ip = result['interfaces_ip']

    try:
        device.close()
    except Exception as e:
        module.fail_json(msg="cannot close device connection: " + str(e))


    nb = pynetbox.api(netbox_url, token=netbox_token)
    try:
        nb_device = nb.dcim.devices.get(name=hostname.split('.')[0])
    except Exception as e:
        module.fail_json(msg="[{}] error when connection to Netbox: ".format(getter) + str(e))

    module.exit_json(**result)

    # We add IPv4 and IPv6 addresses to NB
    for family in [ 4, 6 ]:
        for if_name, ips in interfaces_ip.items():
            # We ignore XXX.0 interface on Juniper devices
            m = re.search('(^.*)\.0$', if_name)
            if m:
                if_name = m.group(1)

            if _ignore_interface(if_name):
                continue

            nb_interface = nb.dcim.interfaces.get(name=str(if_name), device_id=nb_device.id)
            if not nb_interface:
                continue

            if not'ipv'+str(family) in ips:
                continue

            for ip, ip_properties in ips['ipv'+str(family)].items():
                address = str(ip) + '/' + str(ip_properties['prefix_length'])
                # y a un probleme la, ca devrait pouvoir utiliser .get() mais non ..
                #nb_addresses = nb.ipam.ip_addresses.filter(family=family, address=address, interface_id=nb_interface.id)
                nb_addresses = nb.ipam.ip_addresses.filter(family=family, interface_id=nb_interface.id)

                if _found_ip_address(nb_addresses, address):
                    continue
                new_ip = {
                        "family": family,
                        "address": str(address),
                        "interface": nb_interface.id
                }
                nb.ipam.ip_addresses.create(**new_ip)
                # Management IP addresses


    # Now we remove IPv4 and IPv6 addresses not on the device
    for family in [ 4, 6 ]:
        nb_addresses = nb.ipam.ip_addresses.filter(family=family, device_id=nb_device.id)
        for a in nb_addresses:
            ifd_name = a.interface.name
            if '.' not in ifd_name and nb_device.device_type.manufacturer.name == "Juniper":
                ifd_name = ifd_name + '.0'

            #ip = str(a.address.ip)
            #prefix_length = int(a.address.prefixlen)
            ip = str(a.address).split('/')[0]
            prefix_length = str(a.address).split('/')[1]
            try:
                if interfaces_ip[ifd_name]['ipv'+str(family)][ip]['prefix_length'] != prefix_length:
                        a.delete()
            except KeyError:
                a.delete()


    try:
        primary_addr = socket.gethostbyname(hostname)
        mgmt_address = _get_ip_address(nb.ipam.ip_addresses.filter(family=4, device_id=nb_device.id), address=str(primary_addr))
        nb_device.primary_ip = mgmt_address.id
        nb_device.primary_ip4 = mgmt_address.id
        nb_device.save()
    except:
        pass

    # if the user is working with this module in only check mode we do not
    # want to make any changes to the environment, just return the current
    # state with no modifications
    if module.check_mode:
        module.exit_json(**result)



    # in the event of a successful module execution, you will want to
    # simple AnsibleModule.exit_json(), passing the key/value results
    module.exit_json(**result)





def main():
    run_module()

if __name__ == '__main__':
    main()
