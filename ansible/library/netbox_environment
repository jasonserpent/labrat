#!/usr/bin/env python

# References:
# pynetbox API:
#  https://pynetbox.readthedocs.io/en/latest/index.html


ANSIBLE_METADATA = {
    'metadata_version': '1.0',
    'status': ['preview'],
    'supported_by': 'Pedro Antunes <pedro.antunes@forcepoint.com>'
}



import sys
import pynetbox
import re
from ansible.module_utils.basic import AnsibleModule

from jnpr.junos import Device
from jnpr.junos.exception import RpcError
from lxml import etree

napalm_found = False
try:
    from napalm import get_network_driver
    from napalm.base import ModuleImportError
    napalm_found = True
except ImportError:
    pass



def _get_interface_names(interfaces):
    names = []
    for i in interfaces:
        names.append(i.name)
    return names

def _get_interface_by_name(interfaces, name):
    for i in interfaces:
        if i.name == name:
            return i


def run_module():
    # define available arguments/parameters a user can pass to the module
    module_args = dict(
        netbox_url=dict(type='str', required=True),
        netbox_token=dict(type='str', required=True),
        hostname=dict(type='str', required=False, aliases=['host']),
        username=dict(type='str', required=False),
        password=dict(type='str', required=False, no_log=True),
        provider=dict(type='dict', required=False),
        dev_os=dict(type='str', required=False),
        timeout=dict(type='int', required=False, default=60),
        ignore_notimplemented=dict(type='bool', required=False, default=False),
        args=dict(type='dict', required=False, default=None),
        optional_args=dict(type='dict', required=False, default=None)
    )


    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )


    provider = module.params['provider'] or {}

    # allow host or hostname
    provider['hostname'] = provider.get('hostname', None) or provider.get('host', None)
    # allow local params to override provider
    for param, pvalue in provider.items():
        if module.params.get(param) is not False:
            module.params[param] = module.params.get(param) or pvalue

    hostname = module.params['hostname']
    username = module.params['username']
    netbox_url = module.params['netbox_url']
    netbox_token = module.params['netbox_token']
    dev_os = module.params['dev_os']
    password = module.params['password']
    timeout = module.params['timeout']
    args = module.params['args'] or {}
    ignore_notimplemented = module.params['ignore_notimplemented']
    implementation_errors = []


    argument_check = {'hostname': hostname, 'username': username, 'dev_os': dev_os}
    for key, val in argument_check.items():
        if val is None:
            module.fail_json(msg=str(key) + " is required")

    if module.params['optional_args'] is None:
        optional_args = {}
    else:
        optional_args = module.params['optional_args']

    try:
        network_driver = get_network_driver(dev_os)
    except ModuleImportError as e:
        module.fail_json(msg="Failed to import napalm driver: " + str(e))


    try:
        device = network_driver(hostname=hostname,
                                username=username,
                                password=password,
                                timeout=timeout,
                                optional_args=optional_args)
        device.open()
    except Exception as e:
        module.fail_json(msg="cannot connect to device: " + str(e))

    data = {}

    result = dict(
        changed=False
    )


    try:
        for getter in ['facts', 'environment' ]:
            getter_function = "get_{}".format(getter)
            get_func = getattr(device, getter_function)
            data[getter] = get_func(**args.get(getter, {}))

        result['facts'] = data['facts']
        result['environment'] = data['environment']

    except NotImplementedError:
        if ignore_notimplemented:
            implementation_errors.append(getter)
        else:
            module.fail_json(
                msg="The filter {} is not supported in napalm-{} [get_{}()]".format(
                    getter, dev_os, getter))
    except Exception as e:
        module.fail_json(msg="[{}] cannot retrieve device data: ".format(getter) + str(e))

    d_facts = result['facts']
    d_environment = result['environment']

    try:
        device.close()
    except Exception as e:
        module.fail_json(msg="cannot close device connection: " + str(e))


    nb = pynetbox.api(netbox_url, token=netbox_token)
    try:
        nb_device = nb.dcim.devices.get(name=hostname.split('.')[0])
    except Exception as e:
        module.fail_json(msg="[{}] error when connection to Netbox: ".format(getter) + str(e))


    # We update a few facts like
    try:
        nb_device.serial = d_facts['serial_number']
        if nb_device.device_type.manufacturer.name == 'Juniper':
            nb_device.custom_fields['os'] = d_facts['os_version']
            nb_device.platform = nb.dcim.platforms.get(slug="junos")
        else:
            nb_device.custom_fields['os'] = d_facts['os_version'].split('-')[0]
            nb_device.platform = nb.dcim.platforms.get(slug="eos")

        # Let's assume all devices have one and only one console port
        # We delete console ports existing on NB (unless they are connected)
        nb_console_ports = nb.dcim.console_ports.filter(device_id=nb_device.id)
        for cp in nb_console_ports:
            try:
                if not cp.cs_port:
                    cp.delete()
            except:
                pass

        cp_name = 1
        if nb_device.device_type.manufacturer.name == 'Juniper':
            cp_name = "CON0"
        new_cp = {
                "device": nb_device.id,
                "name": str(cp_name)
        }
        try:
            nb.dcim.console_ports.create(**new_cp)
        except:
            pass


        # On Juniper MX devices, PSU seem to appear under the 'temperature' section
        if nb_device.device_type.manufacturer.name == 'Juniper' and re.match('^MX', nb_device.device_type.model) and nb_device.device_type.model != "MX204":
            power_section = 'temperature'
        else:
            power_section = 'power'

        # We add the PSU to NB
        for psu_name in d_environment[power_section].keys():
            if nb_device.device_type.manufacturer.name == 'Juniper':
                # On Juniper MX we are only interested in items labelled ^PEM
                if re.match('^MX', nb_device.device_type.model):
                    if not re.match('^PEM', psu_name):
                        continue
                # On Juniper non-MX we are not interested in items labelled Airflow
                else:
                    if re.match('.*Airflow$', psu_name):
                        continue

            if nb.dcim.power_ports.get(device_id=nb_device.id, name=psu_name):
                continue
            new_psu = {
                    "device": nb_device.id,
                    "name": str(psu_name)
            }
            nb.dcim.power_ports.create(**new_psu)


        # We delete PSU existing on NB but not on the device
        nb_psu = nb.dcim.power_ports.filter(device_id=nb_device.id)
        for psu in nb_psu:
            try:
                if not str(psu.name) in d_environment[power_section].keys():
                    psu.delete()
        #        if nb_device.device_type.manufacturer.name == 'Juniper' and not re.match('^PEM', str(psu.name)):
        #            psu.delete()
            except:
                pass

        nb_device.save()

    except Exception as e:
        module.fail_json(msg="Unable to find device interfaces on Netbox: ".format() + str(e))

    # Juniper only
    # Another loop to
    #   - figure out if the device is a VC. If yes we add one console port per chassis
    #   - figure out if the device is a VC. If yes create the VC
    # Definitely not optimized...
    if nb_device.device_type.manufacturer.name == "Juniper":
        juniper_connection = Device(host=hostname, user=username, passwd=password, port=22) 
        juniper_connection.open(gather_facts=False)
        try:
            vc_info = juniper_connection.rpc.get_virtual_chassis_information()
            chassis_count = vc_info.xpath('count(member-list/member)')

            if chassis_count > 1:
                new_vc = {
                        "domain": nb_device.name,
                        "master": nb_device.id
                }
                try:
                    nb.dcim.virtual_chassis.create(**new_vc)
                    nb_device = nb.dcim.devices.get(name=hostname.split('.')[0])
                    nb_device.vc_position = 0
                    nb_device.save()
                except:
                    pass

            
            while chassis_count > 1:
                cp_name = "CON"+str(int(chassis_count-1))
                new_cp = {
                        "device": nb_device.id,
                        "name": str(cp_name)
                }
                chassis_count = chassis_count - 1
                try:
                    nb.dcim.console_ports.create(**new_cp)
                except RpcError as e:
                    pass
                except:
                    pass

        except RpcError:
            pass

        juniper_connection.close()



    # if the user is working with this module in only check mode we do not
    # want to make any changes to the environment, just return the current
    # state with no modifications
    if module.check_mode:
        module.exit_json(**result)



    # in the event of a successful module execution, you will want to
    # simple AnsibleModule.exit_json(), passing the key/value results
    module.exit_json(**result)





def main():
    run_module()

if __name__ == '__main__':
    main()
