#!/usr/bin/env python

# References:
# pynetbox API:
#  https://pynetbox.readthedocs.io/en/latest/index.html


ANSIBLE_METADATA = {
    'metadata_version': '1.0',
    'status': ['preview'],
    'supported_by': 'Pedro Antunes <pedro.antunes@forcepoint.com>'
}



import sys
import pynetbox
import re
import json
import datetime
import socket
import urllib2
from lxml import etree
from ansible.module_utils.basic import AnsibleModule

DELL_API_WARRANTY_URL = "https://api.dell.com/support/assetinfo/v4/getassetwarranty/"

STATIC_IFD_CHOICES = {
        'Virtual': 0,
        'LAG': 200,
        'Other': 32767
        }

def _guess_interface_formfactor(nb_device, if_name):

    #if 'Port-Channel' in if_name or ('ae' in if_name and not '.' in if_name):
    if re.match('^(bond\d+)$', if_name):
       return STATIC_IFD_CHOICES['LAG']
    elif re.match('^(vnet\d+|macvtap\d+|virbr\d+|lo)$', if_name):
        return STATIC_IFD_CHOICES['Virtual']
    elif re.match('.*\..*', if_name):
        return STATIC_IFD_CHOICES['Virtual']

    return STATIC_IFD_CHOICES['Other']

def _get_ip_address(addresses, address):
    if not addresses:
        return

    for a in addresses:
        if str(a).split('/')[0] == address:
            return a

    return

def run_module():
    # define available arguments/parameters a user can pass to the module
    module_args = dict(
        hostname=dict(type='str', required=False, aliases=['host']),
        netbox_url=dict(type='str', required=True),
        netbox_token=dict(type='str', required=True),
        dell_api_key=dict(type='str', required=True),
        timeout=dict(type='int', required=False, default=60),
        facts=dict(type='dict', required=True, default=None),
        summary=dict(type='str', required=True, default=None),
        ports=dict(type='str', required=True, default=None),
        psu=dict(type='str', required=True, default=None),
        pdisks=dict(type='str', required=True, default=None),
        vdisks=dict(type='str', required=True, default=None),
        provider=dict(type='dict', required=False),
    )


    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )


    provider = module.params['provider'] or {}
    provider['hostname'] = provider.get('hostname', None) or provider.get('host', None)
    # allow local params to override provider
    for param, pvalue in provider.items():
        if module.params.get(param) is not False:
            module.params[param] = module.params.get(param) or pvalue

    hostname = module.params['hostname']
    timeout = module.params['timeout']
    facts = module.params['facts']
    netbox_url = module.params['netbox_url']
    netbox_token = module.params['netbox_token']
    dell_api_key = module.params['dell_api_key']
    try:
        summary = etree.fromstring(module.params['summary'])
    except:
        pass
    try:
        ports = etree.fromstring(module.params['ports'])
    except:
        pass

    try:
        psu = etree.fromstring(module.params['psu'])
    except:
        pass

    try:
        pdisks = etree.fromstring(module.params['pdisks'])
    except:
        pass

    try:
        vdisks = etree.fromstring(module.params['vdisks'])
    except:
        pass

    data = {}

    result = dict(
        changed=False
    )

    #result['facts'] = facts


    nb = pynetbox.api(netbox_url, token=netbox_token)
    try:
        nb_device = nb.dcim.devices.get(name=hostname.split('.')[0])
    except Exception as e:
        module.fail_json(msg="[{}] error when connection to Netbox: ".format(hostname) + str(e))


    nb_items = nb.dcim.inventory_items.filter(device_id=nb_device.id)
    for i in nb_items:
        if 'CPU' in i.name:
            try:
                i.delete()
            except:
                pass

    if facts:
        #nb_device.custom_fields['cpu'] = str(facts['processor'][2])
        #nb_device.custom_fields['cpu_count'] = str(facts['processor_count'])
        #nb_device.custom_fields['cores_per_cpu'] = str(facts['processor_cores'])
        #nb_device.custom_fields['threads_per_core'] = str(facts['processor_threads_per_core'])
        nb_device.custom_fields['os'] = str(
                facts['facter_os']['family'] + ' ' +
                facts['facter_os']['name'] + ' ' +
                facts['facter_os']['release']['full'])
        nb_device.custom_fields['architecture'] = str(facts['facter_os']['hardware'])
        nb_device.custom_fields['ram'] = int(facts['memtotal_mb'])
        #nb_device.comments = str(facts['lsb'])
        #nb_device.comments = str(facts)
        nb_device.save()
        c = 0
        while c < int(facts['processor_count']):
            new_cpu = {
                    "device": nb_device.id,
                    "name": "CPU",
                    "manufacturer": nb.dcim.manufacturers.get(slug="intel").id,
                    "discovered": True,
                    "description": str(facts['processor'][2])
            }
            nb.dcim.inventory_items.create(**new_cpu)
            c += 1


    serial_number = summary.xpath('//ServiceTag')[0].text
    nb_device.serial = serial_number
    nb_device.save()

    #Warranty
    query_string = "%s%s?apikey=%s" % (DELL_API_WARRANTY_URL, serial_number, dell_api_key)
    response = urllib2.urlopen(query_string)
    warranty_data = json.load(response)
    end_date = datetime.datetime.strptime(warranty_data['AssetWarrantyResponse'][0]["AssetEntitlementData"][0]["EndDate"], "%Y-%m-%dT%H:%M:%S")
    nb_device.custom_fields['warranty'] = end_date.strftime('%Y-%m-%d')


    # Console ports
    nb_console_ports = nb.dcim.console_ports.filter(device_id=nb_device.id)
    for cp in nb_console_ports:
        try:
            if not cp.cs_port:
                cp.delete()
        except:
            pass
    try:
        for cp in ports.xpath('/OMA/PortsList/Port[@objtype="193"]/ExtName'):
            new_cp = {
                "device": nb_device.id,
                "name": cp.text
            }
            try:
                nb.dcim.console_ports.create(**new_cp)
            except:
                pass
    except:
        pass

    # PSUs
    try:
        for ps in psu.xpath('/OMA/Chassis/PowerSupplyList/PowerSupply/PSLocation'):
            new_ps = {
                "device": nb_device.id,
                "name": ps.text
            }
            try:
                nb.dcim.power_ports.create(**new_ps)
            except:
                pass
    except:
        pass


    # Disk manufacturers
    try:
        for item in pdisks.xpath('/OMA/ArrayDisks/DCStorageObject'):
            manufacturer_name = item.xpath('DiskProductVendor')[0].text
            new_manufacturer = {
                    "name": manufacturer_name,
                    "slug": manufacturer_name.lower()
            }
            try:
                nb.dcim.manufacturers.create(**new_manufacturer)
            except:
                pass
    except:
        pass
    # Disks
    nb_items = nb.dcim.inventory_items.filter(device_id=nb_device.id)
    for i in nb_items:
        if 'Disk' in i.name:
            try:
                i.delete()
            except:
                pass
    try:
        for item in pdisks.xpath('/OMA/ArrayDisks/DCStorageObject'):
            new_inventory_item = {
                    "device": nb_device.id,
                    "name": "Physical Disk 0:{}:{}".format(item.xpath('EnclosureID')[0].text, item.xpath('TargetID')[0].text),
                    "manufacturer": nb.dcim.manufacturers.get(slug=item.xpath('DiskProductVendor')[0].text.lower()).id,
                    "part_id": item.xpath('ProductID')[0].text,
                    "serial": item.xpath('DeviceSerialNumber')[0].text,
                    "discovered": True,
                    "description": str(int(item.xpath('ArraySize')[0].text) / 1024 ** 3) + ' GB'
            }
            try:
                nb.dcim.inventory_items.create(**new_inventory_item)
            except:
                pass
    except:
        pass
    try:
        for item in vdisks.xpath('/OMA/VirtualDisks/DCStorageObject'):
            new_inventory_item = {
                    "device": nb_device.id,
                    "name": "Virtual Disk " + item.xpath('DeviceName')[0].text,
                    "manufacturer": nb_device.device_type.manufacturer.id,
                    "discovered": True,
                    "description": str(int(item.xpath('Length')[0].text) / 1024 ** 3) + ' GB'
            }
            try:
                nb.dcim.inventory_items.create(**new_inventory_item)
            except:
                pass
    except:
        pass


    if not facts:
        module.exit_json(**result)





    # Now we delete interfaces present on Netbox that do not exist on the device
    nb_interfaces = nb.dcim.interfaces.filter(device_id=nb_device.id)
    for i in nb_interfaces:
        if_name = i.name
        try:
            if not if_name in facts.keys() or '_' in if_name:
                i.delete()
        except Exception as e:
            pass

    # Now we remove IPv4 and IPv6 addresses not on the device
    for family in [ 4, 6 ]:
        nb_addresses = nb.ipam.ip_addresses.filter(family=family, device_id=nb_device.id)
        for a in nb_addresses:
            a.delete()


    for if_name in facts['interfaces']:
        if not if_name in facts:
            continue

        nb_if_name = if_name
        m = re.search('^(.*)_[^\.]+(\.[0-9]+)?$', if_name)
        if m:
            nb_if_name = m.group(1)
            if m.group(2):
                nb_if_name += m.group(2)


        form_factor = _guess_interface_formfactor(nb_device, nb_if_name)

        new_ifd = {
            "device": nb_device.id,
            "name": str(nb_if_name),
            "lag": None,
            "form_factor": form_factor
        }

        try:
            nb.dcim.interfaces.create(**new_ifd)
        except Exception as e:
            pass


        nb_interface = nb.dcim.interfaces.get(name=str(nb_if_name), device_id=nb_device.id)

        if 'macaddress' in facts[if_name]:
            nb_interface.mac_address = str(facts[if_name]['macaddress']).upper()
        if 'mtu' in facts[if_name]:
            nb_interface.mtu = str(facts[if_name]['mtu'])
        nb_interface.lag = None
        nb_interface.form_factor = form_factor
        if 'active' in facts[if_name]:
            nb_interface.enabled = bool(facts[if_name]['active'])
        nb_interface.save()


        for family in ('ipv4', 'ipv6'):
            nb_addresses = nb.ipam.ip_addresses.filter(family=family, device_id=nb_device.id)
            for nb_a in nb_addresses:
                mb_a.delete()

        if 'ipv4' in facts[if_name]:
            new_ip = {
                    "family": 'ipv4',
                    "address": str(
                          facts[if_name]['ipv4']['address'] + '/' +
                          facts[if_name]['ipv4']['netmask']
                    ),
                    "interface": nb_interface.id
            }
            nb.ipam.ip_addresses.create(**new_ip)


        if 'ipv4_secondaries' in facts[if_name]:
            for ip4 in facts[if_name]['ipv4_secondaries']:
                new_ip = {
                        "family": 'ipv4',
                        "address": str(
                          ip4['address'] + '/' +
                          ip4['netmask']
                        ),
                        "interface": nb_interface.id
                }
                nb.ipam.ip_addresses.create(**new_ip)

        if 'ipv6' in facts[if_name]:
            for ip6 in facts[if_name]['ipv6']:
                new_ip = {
                        "family": 'ipv6',
                        "address": str(
                            ip6['address'] + '/' +
                            ip6['prefix']
                        ),
                        "interface": nb_interface.id
                }
                nb.ipam.ip_addresses.create(**new_ip)


    try:
        primary_addr = socket.gethostbyname(hostname)
        mgmt_address = _get_ip_address(nb.ipam.ip_addresses.filter(family=4, device_id=nb_device.id), address=str(primary_addr))
        nb_device.primary_ip = mgmt_address.id
        nb_device.primary_ip4 = mgmt_address.id
        nb_device.save()
    except:
       pass

    for nb_interface in nb.dcim.interfaces.filter(device_id=nb_device.id):
        if_name = nb_interface.name
        if not 'slaves' in facts[if_name]:
            continue
        if re.match('^bond[0-9]+$', if_name):
            slaves = facts[if_name]['slaves']
            for m in slaves:
                try:
                    m_nb_interface = nb.dcim.interfaces.get(name=str(m), device_id=nb_device.id)
                    m_nb_interface.lag = nb_interface.id
                    m_nb_interface.save()
                except Exception as e:
                    pass

    # if the user is working with this module in only check mode we do not
    # want to make any changes to the environment, just return the current
    # state with no modifications
    if module.check_mode:
        module.exit_json(**result)



    # in the event of a successful module execution, you will want to
    # simple AnsibleModule.exit_json(), passing the key/value results
    module.exit_json(**result)





def main():
    run_module()

if __name__ == '__main__':
    main()
