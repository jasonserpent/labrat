#!/usr/bin/env python

# References:
# pynetbox API:
#  https://pynetbox.readthedocs.io/en/latest/index.html

from paramiko import client

import select
from pynetbox import RequestError
import pynetbox
import re

from ansible.module_utils.basic import AnsibleModule

ANSIBLE_METADATA = {
    'metadata_version': '1.0',
    'status': ['preview'],
    'supported_by': 'Pedro Antunes <pedro.antunes@forcepoint.com>'
}


MAX_TRIES = 50000
TS_MAX_PORTS = 32

STATIC_IFD_CHOICES = {
        'Virtual': 0,
        'LAG': 200,
        'Other': 32767
        }

class RaritanPortBusyError(Exception):
    pass

class RaritanNoData(Exception):
    pass

class RaritanUnableToFindName(Exception):
    pass

class RaritanSSH:
    client = None
    channel = None
    banner = ""


    @staticmethod
    def strip_first_line(lines):
        lines = lines.splitlines()
        lines.pop(0)
        return '\n'.join(lines)

    @staticmethod
    def strip_last_line(lines):
        lines = lines.splitlines()
        lines.pop()
        return '\n'.join(lines)

    @staticmethod
    def strip_first_and_last_lines(lines):
        lines = lines.splitlines()
        try:
            lines.pop(0)
            lines.pop()
            return '\n'.join(lines)
        except IndexError:
            return ''

    @staticmethod
    def guess_hostname(output):
        lines = output.splitlines()
        for line in lines:
            m = re.search('@?([a-zA-Z]+\d\d[\-a-zA-Z]+)[#>\s:]', line)
            if m:
                return m.group(1)
        raise RaritanUnableToFindName

    def __init__(self, address, username, password):
        #print("Connecting to server.")
        self.client = client.SSHClient()
        self.client.set_missing_host_key_policy(client.AutoAddPolicy())
        self.client.connect(address, username=username, password=password, look_for_keys=False, allow_agent=False)
        self.channel = self.client.invoke_shell()
        data_already_received = False
        times_skipped = 0
        while not self.channel.exit_status_ready():
            #print("Beginning of main while loop")
            rl, wl, xl = select.select([self.channel], [], [], 0.0)
            if len(rl) > 0:
                #print("Reading data")
                times_skipped = 0
                data_already_received = True
                prevdata = self.channel.recv(1024)
                self.banner += prevdata
            elif times_skipped > MAX_TRIES:
                #print("{}".format(times_skipped))
                break
            elif data_already_received:
                times_skipped += 1



    def close(self):
        self.client.close()


    def _sendCommand(self, command):
        #print("Executing command {}.".format(command))
        alldata = ""
        prevdata = ""
        if(self.channel):
            self.channel.send(command+"\r")


            # Works with Juniper devices
            #while not stdout.channel.exit_status_ready():
            #    #print("Beginning of main while loop")
            #    rl, wl, xl = select.select([stdout.channel], [], [], 0.0)
            #    if len(rl) > 0:
            #        prevdata = stdout.channel.recv(1024)
            #        alldata += prevdata

            ## Attempt with Raritan
            data_already_received = False
            times_skipped = 0
            global_times_skipped = 0
            while not self.channel.exit_status_ready():
                #print("While loop")
                global_times_skipped += 1
                rl, wl, xl = select.select([self.channel], [], [], 0.0)
                if len(rl) > 0:
                    #print("Reading data")
                    times_skipped = 0
                    data_already_received = True
                    prevdata = self.channel.recv(1024)
                    alldata += prevdata
                elif times_skipped > MAX_TRIES:
                    #print("{}".format(times_skipped))
                    break
                elif data_already_received:
                    times_skipped += 1
                elif not data_already_received and global_times_skipped > 10 * MAX_TRIES:
                    raise RaritanNoData("No data received")

            return str(alldata)
        else:
            print('Connection not opened.')

    def _sendEnter(self):
        return self._sendCommand('\r')

    def connectPort(self, port_id):
        self._sendEnter()
        output = self._sendCommand('connect '+str(port_id))
        if RaritanSSH.strip_first_and_last_lines(output) == '\nSorry, port is busy!':
            raise RaritanPortBusyError('Sorry, port is busy!')
        #print("...{}...".format(RaritanSSH.strip_first_and_last_lines(output)))
        output = self._sendEnter()
        output = self._sendEnter()
        return RaritanSSH.strip_first_line(output)

    def disconnectPort(self):
        try:
            self._sendCommand('\x1d')
            self._sendCommand('quit')
        except:
            pass


def run_module():
    # define available arguments/parameters a user can pass to the module
    module_args = dict(
        netbox_url=dict(type='str', required=True),
        netbox_token=dict(type='str', required=True),
        hostname=dict(type='str', required=False, aliases=['host']),
        username=dict(type='str', required=False),
        password=dict(type='str', required=False, no_log=True),
        provider=dict(type='dict', required=False),
        timeout=dict(type='int', required=False, default=60),
    )


    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )


    provider = module.params['provider'] or {}

    # allow host or hostname
    provider['hostname'] = provider.get('hostname', None) or provider.get('host', None)
    # allow local params to override provider
    for param, pvalue in provider.items():
        if module.params.get(param) is not False:
            module.params[param] = module.params.get(param) or pvalue

    hostname = module.params['hostname']
    username = module.params['username']
    password = module.params['password']
    timeout = module.params['timeout']
    netbox_url = module.params['netbox_url']
    netbox_token = module.params['netbox_token']


    argument_check = {'hostname': hostname, 'username': username}
    for key, val in argument_check.items():
        if val is None:
            module.fail_json(msg=str(key) + " is required")


    nb = pynetbox.api(netbox_url, token=netbox_token)
    nb_ts_device = nb.dcim.devices.get(name=hostname.split('.')[0])

    ts_device = RaritanSSH(address=hostname, username=username, password=password)

    data = ""

    result = dict(
        changed=False
    )


    # Assumed : the TS has two interfaces called LAN1 and LAN2
    # We do not update IP addresses
    for if_name in ("LAN1", "LAN2"):
        new_ifd = {
                "device": nb_ts_device.id,
                "mgmt_only": True,
                "name": str(if_name),
                "form_factor": STATIC_IFD_CHOICES['Other']
        }

        try:
            nb.dcim.interfaces.create(**new_ifd)
        except Exception as e:
            continue

    # Assumed : the TS has two PS called PowerIn1 and PowerIn2
    # We do not update IP addresses
    for psu_name in ("PowerIn1", "PowerIn2"):
        new_psu = {
                "device": nb_ts_device.id,
                "name": str(psu_name)
        }
        try:
            nb.dcim.power_ports.create(**new_psu)
        except Exception as e:
            continue


    # Assumed : the TS has one console port named 0
    new_cp = {
            "device": nb_ts_device.id,
            "name": str(0)
    }
    try:
        nb.dcim.console_ports.create(**new_cp)
    except:
        pass



    # Let's now actually create the console server ports
    # We assume there are 32 of them
    i = 1
    hack_vc = {}
    while i <= TS_MAX_PORTS:
        try:
            new_csp = {
                    "device": nb_ts_device.id,
                    "name": str(i)
            }
            try:
                nb.dcim.console_server_ports.create(**new_csp)
            except:
                pass

            #print("Connecting to port {}.".format(i))
            output = ts_device.connectPort(i)
            #print("output=...{}...\n".format(output)),
            connected_host = RaritanSSH.guess_hostname(output=output)
            data += "Port {} is {}.\n".format(i, connected_host)
            ts_device.disconnectPort()

            #Now we finally add the connection to NB
            try:
                nb_network_device = nb.dcim.devices.get(name=connected_host)
                nb_cp_a = nb.dcim.console_server_ports.get(device_id=nb_ts_device.id, name=str(i))
                try:
                    hack_vc[nb_network_device.name] += 1
                except:
                    hack_vc[nb_network_device.name] = 0
                nb_cp_b = nb.dcim.console_ports.filter(device_id=nb_network_device.id)[hack_vc[nb_network_device.name]]
                nb_cp_b.cs_port = nb_cp_a.id
                nb_cp_b.connection_status = True
                nb_cp_b.save()
            except (RequestError, TypeError, AttributeError, ValueError, IndexError) as e:
                pass

        except RaritanUnableToFindName:
            data += "Port {} : Unable to find name.\n".format(i)
            ts_device.disconnectPort()
        except RaritanPortBusyError:
            data += "Port {} : Unable to connect (Port busy).\n".format(i)
        except RaritanNoData:
            #print("Nodata for port {}".format(i))
            data += "Port {} : Unable to connect (No answer).\n".format(i)
            ts_device.disconnectPort()

            #connection.close()
            #break
            #connection.disconnectPort(i)

        i += 1


    ##output=connection.sendCommand("listports")
    ts_device.close()



    result['found'] = data


    # if the user is working with this module in only check mode we do not
    # want to make any changes to the environment, just return the current
    # state with no modifications
    if module.check_mode:
        module.exit_json(**result)



    # in the event of a successful module execution, you will want to
    # simple AnsibleModule.exit_json(), passing the key/value results
    module.exit_json(**result)





def main():
    run_module()

if __name__ == '__main__':
    main()
